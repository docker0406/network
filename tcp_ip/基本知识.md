## 协议的层次与模型
OSI七层模型:  
* 应用层：允许访问OSI环境的手段。HTTP, FTP, DNS, SMTP, Telnet 
* 表示层：对数据进行翻译，加密和压缩。JPEG, MPEG, ASII 
* 会话层：建立，管理和终止回话。NFS, SQL, RPC 
* 传输层：提供不同端系统的进程间通信。TCP, UDP, SPX 
* 网络层：提供主机之间的通信。IP, ICMP, ARP, RAPR, RIP, OSPF, BGP-4 (路由器) 
* 数据链路层：提供网络中点到点之间数据帧的传递。PPP, FR, HDLC, VLAN, MAC (网桥，交换机) 
* 物理层：提供在物理介质上每一比特的传输。RJ45, CLOCK, IEEE802.3 (中继器，集线器，网关)

Internet五层模型:  
* 应用层：将应用程序的报文交给传输层 
* 传输层：将接收的报文分段，封装TCP/UDP头部信息，将报文段传递给网络层 
* 网络层：将接收的报文段封装IP头部信息，将数据报交给数据链路层 
* 数据链路层：将接收网络层的数据报，封装数据帧头部信息，将数据帧从一个节点通过链路传到另一个节点 
* 物理层：数据链路层负责将一个个数据帧从一点传递到另一点，物理层负责一个个比特从一点传递到另一点

## 概述TCP协议
TCP协议是一种点对点的，面向连接的，全双工的服务的，面向字节流的，可靠的，具有拥塞控制的传输层协议 点对点：TCP连接只能是一对一建立的 面向连接：TCP协议在传输数据之前需要建立连接 全双工服务：TCP连接建立之后，连接双方都可以同时向对方发送数据 面向字节流的：TCP把数据看成无结构的，有序的字节流，TCP的序号是建立在字节流上而不是建立在报文段上 可靠的：TCP采用确认重传机制，序号机制，定时器机制，快速重传，滑动窗口机制，流量控制等来保证数据传输的可靠性 拥塞控制：TCP采用慢启动，拥塞避免，快速恢复的机制来进行拥塞控制，共避免网络空间陷入拥塞

TCP报文头部 源端口号：发送方进程端口号 目的端口号：接收方进程端口号 序号：32比特，建立在字节流上的序号机制 确认号：32比特，确认号表示期望收到的下一字节的序号，与序号共同保证TCP的可靠传输 首部长度：TCP首部长度，因为选项字段的存在，一般无选项头部长为20字节 URG：表示报文段中存在被发送方指示为紧急的数据。紧急数据由紧急数据指针指出 ACK：确认标志位，表示首部的确认号有效 PSH：表示接收方应立即将接收的数据交付给上层。因为TCP接收方可能存在接收缓存，接收方可能在忙其他事情，可能等接收缓存满的时候，才会将数据交付给上层，PSH标志位表示接收方应立即将数据交付上层 RST：表示复位，用来异常的关闭连接，引发RST的原因主要有：提前关闭，请求超时，端口未打开，在一个已关闭的SOCKET接收到数据 SYN：建立TCP连接时的标志位 FIN：关闭TCP连接时的标志位 接收窗口：表示接收方还有多少缓存供接收，用于控制发送方的发送速率，以免溢出。用于流量控制 检验和：首部+数据全部的检验和 紧急数据指针：与URG标志位共同使用，指出数据中的紧急数据字段

TCP的可靠数据传输 TCP的可靠数据传输服务保证应用进程从接收缓存中读取的数据是不错，不乱，不丢的数据 确认：只发送ACK确认被正确接收的分组，不发NAK，确认号是期望收到的下一字节 序号：序号基于无结构，有序的字节流。序号表示该报文段的首字节的字节流编号 定时器：TCP设置单一定时器 累计确认：TCP采用累计确认，即接收方发送确认号为x的ACK，表示x之前的报文段都已被正确的接收；但是采用全部重传还是选择重传，TCP没有明确规定 超时重传：如果报文段的传输时间超时，则重传 快熟重传：当发送方收到三个重复ACK（即共4个ACK），则快速重传该报文段

TCP流量控制 因为接收方设置有限的接收缓存，如果发送方发送速率过大的话，接收方缓存可能溢出，导致不必要的分组丢失 所以流量控制是为了限制发送方的发送速率，来保证接收方可以来得及接收到来的报文段 接收方在头部的接收窗口告诉发送方，接收缓存还剩多少，即还能接收多少数据，发送方保证发送的数据量不超过这个量 若接收方告知接收窗口为0了，为避免阻塞，发送方仍发送数据量为1的报文段，接收方接收并回复ACK，并同时告知此时的接收窗口大小 发送方的发送速率由流量控制的接收窗口大小与拥塞控制的拥塞窗口大小共同控制

TCP的拥塞控制 发送方控制自己的发送速率，避免公共网络陷入拥塞，所有TCP发送方共同维护公共网络 拥塞控制与流量控制的区别：流量控制是考虑端到端之间的问题，是避免发送方发送速率过快导致接收方来不及接收，考虑的是私人利益；拥塞控制考虑的是公共网络，避免发送方发送速率过快而导致网络陷入拥塞，考虑的是公共网络的问题 TCP在发送方维护一个CWND的拥塞窗口变量，与接收窗口RWND共同控制发送速率（滑动窗口的大小） TCP根据丢包事件来感知网络的拥塞状态，如果发生超时丢包事件，则说明网络已经比较拥塞了，数据已经传输不到接收方；如果重复ACK丢包事件，则表示网络可能即将陷入拥塞，但是没有那么严重，因为数据还能传输到接收方 拥塞控制方法 慢启动：TCP启动速度很慢，一般从MSS从1开始，但是希望快速找到可用带宽的数量，发送速率指数增长，知道遇到丢包时间，则设置一个阀值等于丢包时的速率的一般，即ssthresh = CWND/2 拥塞避免：如果是超时事件引起的丢包，则进入拥塞避免状态，拥塞避免状态将阀值设为拥塞窗口值的一半之后，将速率设为MSS = 1，然后开始指数增长，直到达到阀值ssthresh，此时可能即将进入拥塞状态了，所以之后再线性增长，直到遇到丢包事件 快速恢复：如果是3个重复ACK引起的丢包事件，此时TCP执行快速重传，并进入快速恢复状态，将阀值设为拥塞窗口值的一般，即ssthresh = CWND/2，然后将发送速率降为阀值ssthresh，之后线性增长，直到遇到丢包事件

## TCP和UDP的区别
1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的, 
4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低
5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
6. TCP首部开销20字节;UDP的首部开销小，只有8个字节
7. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

## TCP三次握手
TCP提供的可靠数据传输服务，是依靠接收端TCP软件按序号对收到的数据分组进行逐一确认实现的。  
三次握手协议指的是在发送数据的准备阶段，服务器端和客户端之间需要进行三次交互：  
1. 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
2. 第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。  

连接建立后，客户端和服务器就可以开始进行数据传输了。

为什么客户端需要再发送一次确认？  
client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。  
本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。  
于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。  
由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。  
但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。  
采用三次握手的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。  
server由于收不到确认，就知道client并没有要求建立连接。

## TCP的四次挥手协议
（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

### 为什么TCP连接是三次，挥手确是四次？
在TCP连接中，服务器端的SYN和ACK向客户端发送是一次性发送的，而在断开连接的过程中，B端向A端发送的ACK和FIN是是分两次发送的。  
因为在B端接收到A端的FIN后，B端可能还有数据要传输，所以先发送ACK，等B端处理完自己的事情后就可以发送FIN断开连接了。  

### 为什么在第四次挥手后会有2个MSL的延时？
MSL是Maximum Segment Lifetime，最大报文段生存时间，2个MSL是报文段发送和接收的最长时间。  
假定网络不可靠，那么第四次发送的ACK可能丢失，即B端无法收到这个ACK，如果B端收不到这个确认ACK，B端会定时向A端重复发送FIN，  
直到B端收到A的确认ACK。所以这个2MSL就是用来处理这个可能丢失的ACK的。而且能确保下一个新的连接中没有这个旧连接的报文。  

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。  
收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。  
　（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段4）。  
　（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号  
　（3） 服务器关闭客户端的连接，发送一个FIN给客户端（报文段6）。 
　（4） 客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）  
